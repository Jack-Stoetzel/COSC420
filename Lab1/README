Lauren Golian and Jack Stoetzel
2019/09/04
Dr. Anderson
COSC420-001

Description: In the following lab, we apply Message Passing Interface (MPI) to parralleize a primality test for greater efficiency. 

To Run: Simply type 'make' into the command line followed by 'mpiexec a.out (number to test)'.

Solutions to Questions: 
	A. What is the theoretical time complexity of your sorting algorithms (best and worst case), in terms of the input size?
The theoretical time complexity our algorithm yields is O(nlog(n)) and O(log(n)) in the worst and best case scenarios, respectively. As our output suggests, performing the 'primality' test increases the time as nodes are added.
	B. According to the data, does adding more nodes perfectly divide the time taken by the program?
As mentioned in the previous question, when the work is divided across multiple nodes the time to determine a numbers primality increases slightly. (Check Excel File.)
	C. Justify the fact that one needs only check up to (sqrt(N)) in the brute force primality test.
The square root of any number, N, returns two equivalent factors. Therefore, to determine if a number is divisible, a factor less than the square root and greater than the square root can be multipled to equal the inital number, N. To test for primality, only numbers LESS THAN THE SQUARE ROOT need to be tested because no values greater than the square root can be factors of N.
	D. How could the code be improved in terms of usability, effciency, and robustness?
Currently our  primality test implements the 'scatter' model which tasks each node and returns the result with no communication across nodes. To increase efficiency, communication between nodes could eliminate factors that reduce into smaller factors. Example: numbers divisible by 6 are also divisible by 3 and 2 so in the best scenario our code would only test with prime numbers. 
