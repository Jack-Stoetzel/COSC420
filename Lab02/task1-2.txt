/*
Lauren Golian & Jack Stoetzel
September 18, 2019
Dr. Anderson
COSC 420-001

TASK 01
Write a short program to practice using MPI_Scatter and MPI_Reduce where:
(a) A root node generates two random vectors in high dimension (thousands)
(b) “Blocks” of those vectors are then scattered to various nodes, each of
    which performs a partial inner product
(c) The partial inner products are then combined by the root and reported to
    the user
*/

#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>
#include <time.h>

int main(int argc, char** argv){

    MPI_Init(NULL, NULL);
    srand(time(NULL));
    //-------------------------------------------------------------
    int world, rank;

    MPI_Comm comm = MPI_COMM_WORLD;

    MPI_Comm_size(comm, &world);

    MPI_Comm_rank(comm, &rank);
    //-------------------------------------------------------------

    int *arr1, *arr2;
    int arrSize = atoi(argv[1]);
    int divide = arrSize/world;
    int prod = 0, i = 0;

    arr1 = malloc(arrSize * sizeof(int));
    arr2 = malloc(arrSize * sizeof(int));

    if(rank == 0){
        for(; i < arrSize; i++){
            arr1[i] = rand() % 5 + 1;
            arr2[i] = rand() % 5 + 1;
        }
    }

    int block = arrSize / world;
    int overflow = arrSize % world + block;
    int sendCounts[world];
    int displs[world];

    for(i = 0; i < world; i++){
        displs[i] = i * block;
        if( i == world - 1)
            sendCounts[i] = overflow;
        else
            sendCounts[i] = block;
    }

    int final = 0;
    int arrB[sendCounts[rank]];
    int arrA[sendCounts[rank]];

    for(i = 0; i < sendCounts[rank]; i++)
        arrA[i] = 0;

    for(i = 0; i < sendCounts[rank]; i++)
        arrB[i] = 0;

    MPI_Scatterv(arr1, sendCounts, displs, MPI_INT, arrA, sendCounts[rank],
                 MPI_INT, 0, comm);

    MPI_Scatterv(arr2, sendCounts, displs, MPI_INT, arrB, sendCounts[rank],
                 MPI_INT, 0, comm);

    for( i = 0; i < sendCounts[rank]; i++)
        prod += arrA[i] * arrB[i];

    MPI_Reduce(&prod, &final, 1, MPI_INT, MPI_SUM, 0, comm);

    if(rank == 0)
        printf("Inner product of the two vectors is = %d \n", final);

    MPI_Finalize();
    return 0;
}

/*
TASK 02
Write a library to perform the basic matrix operations of addition, 
subtraction, multiplication, and transpose.

(a) Distribute the tasks of addition, by splitting the matrices into “blocks”
(b) For multiplication, each member of the result matrix can be calculated 
    independently, given enough parts of the argument matrices. Consider ways
    to do this distribution efficiently, keeping in mind the cost of 
    replicating the matrices. Be sure to document your procedure and record its
    performance metrics.
(c) Use MPI_Send and MPI_Recv to distribute matrix data
*/


#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>
#include <time.h>


#define INDEX(n, m, i, j) m*i+j
#define ACCESS(A, i, j) A ->arr [INDEX(A -> rows, A -> cols, i, j)]

struct matrix{
	int rows, cols;
	int *arr;
};

void initMatrix(struct matrix* A, int r, int c, int giveValue){
	A -> rows = r;
	A -> cols = c;
	A -> arr = malloc(r*c*sizeof(int));

	if(giveValue){
		int i, k;
		for(i = 0; i < r; i++)
			for(k = 0; k < c; k++)
				ACCESS(A, i, k) = rand() % 10 + 1;
	}
	else{
		int i, k;
		for(i = 0; i < r; i++)
			for(k = 0; k < c; k++)
				ACCESS(A, i, k) = 0;
	}
}

void printMatrix(struct matrix* A){
	int i, k;

	for(i = 0; i < A -> rows; i++){
		for(k = 0; k < A -> cols; k++)
			printf("%d ", ACCESS(A, i, k));
		printf("\n");
	}
}

//DONE
void addMatrixS(struct matrix *A, struct matrix *B, struct matrix *F){
	int i, k;
	for(i = 0; i < A -> rows; i++)
		for(k = 0; k < A -> cols; k++)
			ACCESS(F, i, k) = ACCESS(A, i, k) + ACCESS(B, i, k);
}

//DONE
void addMatrixP(struct matrix *A, struct matrix *B, struct matrix *F,
			    MPI_Comm comm, int world, int rank){


	int arrSize= A -> rows * A -> cols;
	int block = arrSize / world;
	int overflow = arrSize % world + block;

	int sendCounts[world];
	int displs[world];

	int i;

	for(i = 0; i < world; i++){
		displs[i] = i * (block);
		if(i == world - 1)
			sendCounts[i] = overflow;
		else
			sendCounts[i] = block;
	}

	int arrA[sendCounts[rank]];
	int arrB[sendCounts[rank]];
	int finalArr[sendCounts[rank]];

	for(i = 0; i < sendCounts[rank]; i++)
		arrA[i] = 0;

	for(i = 0; i < sendCounts[rank]; i++)
		arrB[i] = 0;

	MPI_Scatterv(A -> arr, sendCounts, displs, MPI_INT,  arrA,
				 sendCounts[rank], MPI_INT, 0, comm);

	MPI_Scatterv(B -> arr, sendCounts, displs, MPI_INT, arrB,
				 sendCounts[rank], MPI_INT, 0, comm);

	for(i = 0; i < sendCounts[rank]; i++)
		finalArr[i] = arrA[i] + arrB[i];

	MPI_Gatherv(finalArr, sendCounts[rank], MPI_INT, F -> arr, sendCounts,
				displs, MPI_INT, 0, comm);

}

//DONE
void subMatrixS(struct matrix *A, struct matrix *B, struct matrix *F){
	int i, k;
	for(i = 0; i < A -> rows; i++)
		for(k = 0; k < A -> cols; k++)
			ACCESS(F, i, k) = ACCESS(A, i, k) - ACCESS(B, i, k);
}

//DONE
void subMatrixP(struct matrix *A, struct matrix *B, struct matrix *F,
			    MPI_Comm comm, int world, int rank){

	int arrSize= A -> rows * A -> cols;
	int block = arrSize / world;
	int overflow = arrSize % world + block;

	int sendCounts[world];
	int displs[world];

	int i;

	for(i = 0; i < world; i++){
		displs[i] = i * block;
		if(i == world - 1)
			sendCounts[i] = overflow;
		else
			sendCounts[i] = block;
	}

	int arrA[sendCounts[rank]];
	int arrB[sendCounts[rank]];
	int finalArr[sendCounts[rank]];

	for(i = 0; i < sendCounts[rank]; i++)
		arrA[i] = 0;

	for(i = 0; i < sendCounts[rank]; i++)
		arrB[i] = 0;

	MPI_Scatterv(A -> arr, sendCounts, displs, MPI_INT, arrA,
				 sendCounts[rank], MPI_INT, 0, comm);

	MPI_Scatterv(B -> arr, sendCounts, displs, MPI_INT, arrB,
				 sendCounts[rank], MPI_INT, 0, comm);

	for(i = 0; i < sendCounts[rank]; i++)
		finalArr[i] = arrA[i] - arrB[i];

	MPI_Gatherv(finalArr, sendCounts[rank], MPI_INT, F -> arr, sendCounts,
				displs, MPI_INT, 0, comm);

}

//DONE
void multiMatrixS(struct matrix *A, struct matrix *B, struct matrix *F){
	int i, k, n;

		for(i = 0; i < A -> cols; i++)
			for(k = 0; k < B -> cols; k++)
				for(n = 0; n < A -> cols; n++)
					ACCESS(F, i, k) += (ACCESS(A, i, n) * ACCESS(B, n, k));
}

//NOT DONE :(
void multiMatrixP(struct matrix *A, struct matrix *B, struct matrix *F,
				  MPI_Comm comm, int world, int rank){
	struct matrix T;
	initMatrix(&T, B -> rows, B -> cols, 0);
	transposeMatixS(B, &T);

	int i, k, n, prod;
	int *arrA = malloc(A -> cols * sizeof(int));
	int *arrB = malloc(B -> cols * sizeof(int));

	for(i = 0; i < F -> rows; i++){
		for(k = 0; k < F -> cols; k++){
			for(n = 0; n < A -> rows; n++){
				arrA[n] = A -> arr[i * A -> rows + n];
				arrB[n] = T.arr[k * B -> rows + n];
			}
			prod = innerProd(arrA, arrB, A -> cols, comm, world, rank);
			ACCESS(F, i, k) = prod;
		}
	}
}

//DONE
void transposeMatixS(struct matrix *A, struct matrix *F){
	int i, k;
	for(i = 0; i < A -> rows; i++)
		for(k = 0; k < A -> cols; k++)
			ACCESS(F, k, i) = ACCESS(A, i, k);
}

int innerProd(int *arr1, int *arr2, int arrSize, MPI_Comm comm, int world, int rank){
	int divide = arrSize/world;
    int prod = 0, i = 0;

    if(rank == 0){
        for(; i < arrSize; i++){
            arr1[i] = rand() % 5 + 1;
            arr2[i] = rand() % 5 + 1;
        }
    }

    int block = arrSize / world;
    int overflow = arrSize % world + block;
    int sendCounts[world];
    int displs[world];

    for(i = 0; i < world; i++){
        displs[i] = i * block;
        if( i == world - 1)
            sendCounts[i] = overflow;
        else
            sendCounts[i] = block;
    }

    int final = 0;
    int arrB[sendCounts[rank]];
    int arrA[sendCounts[rank]];

    for(i = 0; i < sendCounts[rank]; i++)
        arrA[i] = 0;

    for(i = 0; i < sendCounts[rank]; i++)
        arrB[i] = 0;

    MPI_Scatterv(arr1, sendCounts, displs, MPI_INT, arrA, sendCounts[rank],
                 MPI_INT, 0, comm);

    MPI_Scatterv(arr2, sendCounts, displs, MPI_INT, arrB, sendCounts[rank],
                 MPI_INT, 0, comm);

    for( i = 0; i < sendCounts[rank]; i++)
        prod += arrA[i] * arrB[i];

    MPI_Reduce(&prod, &final, 1, MPI_INT, MPI_SUM, 0, comm);

	if(rank == 0)
		return final;
}

int main(int argc, char** argv){

	MPI_Init(NULL, NULL);
	srand(time(NULL));

	//--------------------------------------------------------------------------
	int world;

	MPI_Comm comm = MPI_COMM_WORLD;

	MPI_Comm_size(comm, &world);

	int rank;

	MPI_Comm_rank(comm, &rank);
	//--------------------------------------------------------------------------

	struct matrix matA, matB, solution, result;

	int doAdd, doMulti;

	initMatrix(&matA, atoi(argv[1]), atoi(argv[2]), 1);

	initMatrix(&matB, atoi(argv[3]), atoi(argv[4]), 1);

	if(rank == 0){

		printf("\033c");
		printf("Matrix A\n");
		printMatrix(&matA);
		printf("\nMatrix B\n");
		printMatrix(&matB);
	}
		//----------------------------------------------------------------------
		//								Matrix A + B

		initMatrix(&solution, matA.rows, matB.cols, 0);

		addMatrixS(&matA, &matB, &solution);

		if(rank == 0){
			puts("\nSolution of A + B");
			printMatrix(&solution);
		}

		initMatrix(&result, matA.rows, matB.cols, 0);

		addMatrixP(&matA, &matB, &result, comm, world, rank);

		if(rank == 0){
			puts("\nResult of A + B");
			printMatrix(&result);

			free(result.arr);
			free(solution.arr);
		}

		//----------------------------------------------------------------------
		//								Matrix A - B

		initMatrix(&solution, matA.rows, matB.cols, 0);

		subMatrixS(&matA, &matB, &solution);

		if(rank == 0){
			puts("\nSolution of A - B");
			printMatrix(&solution);
		}

		initMatrix(&result, matA.rows, matB.cols, 0);

		subMatrixP(&matA, &matB, &result, comm, world, rank);

		if(rank == 0){
			puts("\nResult of A - B");
			printMatrix(&result);

			free(result.arr);
			free(solution.arr);
		}

		//----------------------------------------------------------------------
		//								Matrix B - A

		initMatrix(&solution, matA.rows, matB.cols, 0);

		subMatrixS(&matB, &matA, &solution);

		if(rank == 0){
			puts("\nSolution of B - A");
			printMatrix(&solution);
		}

		initMatrix(&result, matA.rows, matB.cols, 0);

		subMatrixP(&matB, &matA, &result, comm, world, rank);

		if(rank == 0){
			puts("\nResult of B - A");
			printMatrix(&result);

			free(result.arr);
			free(solution.arr);
		}


		//----------------------------------------------------------------------
		//								Matrix A * B

		initMatrix(&solution, matA.rows, matB.cols, 0);

		multiMatrixS(&matA, &matB, &solution);

		if(rank == 0){
			puts("\nSolution of A * B");
			printMatrix(&solution);
		}

		initMatrix(&result, matA.rows, matB.cols, 0);

		multiMatrixP(&matA, &matB, &result, comm, world, rank);

		if(rank == 0){
			puts("\nResult of A * B");
			printMatrix(&result);

			free(result.arr);
			free(solution.arr);
		}

		//----------------------------------------------------------------------
		//								Matrix B * A

		initMatrix(&solution, matA.rows, matB.cols, 0);

		multiMatrixS(&matB, &matA, &solution);

		if(rank == 0){
			puts("\nSolution of B * A");
			printMatrix(&solution);
		}

		initMatrix(&result, matA.rows, matB.cols, 0);


		multiMatrixP(&matB, &matA, &result, comm, world, rank);

		if(rank == 0){
			puts("\nResult of B * A");
			printMatrix(&result);

			free(result.arr);
			free(solution.arr);
		}

	//--------------------------------------------------------------------------
								//Matrix A^(T)

	initMatrix(&result, matA.cols, matA.rows, 0);

	transposeMatixS(&matA, &result);

	if(rank == 0){
		puts("\nResult of A^(T)");
		printMatrix(&result);

		 free(result.arr);
	}

	//--------------------------------------------------------------------------
								//Matrix B^(T)

	initMatrix(&result, matB.cols, matB.rows, 0);

	transposeMatixS(&matB, &result);

	if(rank == 0){
		puts("\nResult of B^(T)");
		printMatrix(&result);

		 free(result.arr);
	}

	//--------------------------------------------------------------------------

	MPI_Finalize();

	free(matA.arr);
	free(matB.arr);

	return 0;

}
